#!/bin/sh /etc/rc.common
# AuthShield init (procd)
# Enforces bans for LuCI/Dropbear by dropping at top of input_lan/input_wan.
# Generates /var/run/authshield.nft as a *script* include for fw4.

USE_PROCD=1
START=60
STOP=15
NAME=authshield

WATCH_BIN="/usr/sbin/authshield.sh"
FW_INCLUDE="/var/run/authshield.nft"

# ---- helpers ----

get_uciv() {
    uci -q get "$1"
}

# Normalize a space/semicolon/comma separated port list into a sorted, deduped CSV (e.g. "80,443")
ports_to_csv() {
    printf '%s\n' "$1" \
    | tr ' ,;' '\n' \
    | awk '
        NF {
            gsub(/[^0-9]/, "")
            if ($0 != "") {
                if (!seen[$0]++) {
                    if (out != "") out = out "," $0
                    else out = $0
                }
            }
        }
        END { print out }
    '
}

ensure_fw_include() {
    # ensure we have a firewall include pointing to $FW_INCLUDE with type 'script'
    local found idx
    found=0
    idx=0
    while :; do
        local path type
        path="$(get_uciv firewall.@include[$idx].path)" || break
        type="$(get_uciv firewall.@include[$idx].type)"
        if [ "$path" = "$FW_INCLUDE" ]; then
            [ "$type" = "script" ] || uci set firewall.@include[$idx].type='script'
            found=1
            break
        fi
        idx=$((idx+1))
    done

    if [ "$found" -eq 0 ]; then
        uci add firewall include >/dev/null
        uci set firewall.@include[-1].type='script'
        uci set firewall.@include[-1].path="$FW_INCLUDE"
    fi
    uci commit firewall
}

write_fw_include() {
    # Read config from UCI (use @settings[0] consistently)
    local ports penalty
    ports="$(get_uciv authshield.@settings[0].ports)"
    penalty="$(get_uciv authshield.@settings[0].penalty)"

    [ -n "$ports" ] || ports="80 443"
    [ -n "$penalty" ] || penalty="60"

    local ports_csv
    ports_csv="$(ports_to_csv "$ports")"
    [ -n "$ports_csv" ] || ports_csv="80,443"

    cat > "$FW_INCLUDE" <<EOF
#!/bin/sh
# Auto-generated by /etc/init.d/authshield â€” DO NOT EDIT.
set -eu

PORTS_CSV="$ports_csv"
PENALTY="$penalty"

# Delete our previous rules (by handle) to avoid duplication
del_old_rules() {
  local chain="\$1"
  nft -a list chain inet fw4 "\$chain" 2>/dev/null | \
    awk '/@authshield_penalty_v[46]/ && / dport / {print \$NF}' | \
    tr -d ';' | while read -r h; do
      [ -n "\$h" ] && nft delete rule inet fw4 "\$chain" handle "\$h" 2>/dev/null || true
    done
}

# Ensure table exists (use shell to avoid nft parse errors)
if ! nft list table inet fw4 >/dev/null 2>&1; then
  nft add table inet fw4
fi

# Recreate penalty sets (delete then add, no "replace set")
nft delete set inet fw4 authshield_penalty_v4 >/dev/null 2>&1 || true
nft delete set inet fw4 authshield_penalty_v6 >/dev/null 2>&1 || true

# Add sets with pure nft syntax (no shell redirects inside)
nft -f - <<NFE
add set inet fw4 authshield_penalty_v4 { type ipv4_addr; flags timeout; timeout \${PENALTY}s; }
add set inet fw4 authshield_penalty_v6 { type ipv6_addr; flags timeout; timeout \${PENALTY}s; }
NFE

# Remove any older insertions we made
del_old_rules input_lan || true
del_old_rules input_wan || true

# Also remove any prior early-drop we inserted in 'input' (idempotent)
del_old_rules input || true

# Insert the early-drop rules BEFORE conntrack established/related accept
nft insert rule inet fw4 input index 1 tcp dport {\${PORTS_CSV}} ip  saddr @authshield_penalty_v4 counter drop 2>/dev/null || true
nft insert rule inet fw4 input index 1 tcp dport {\${PORTS_CSV}} ip6 saddr @authshield_penalty_v6 counter drop 2>/dev/null || true

exit 0
EOF
    chmod +x "$FW_INCLUDE"
}

regen_rules_and_reload_fw() {
    write_fw_include
    ensure_fw_include
    /etc/init.d/firewall reload >/dev/null 2>&1 || true
}

kill_leftovers() {
    # best-effort cleanup of stray watcher shells
    local pids
    pids="$(pgrep -f "$WATCH_BIN" 2>/dev/null || true)"
    [ -z "$pids" ] && return 0
    kill $pids 2>/dev/null || true
    sleep 1
    pids="$(pgrep -f "$WATCH_BIN" 2>/dev/null || true)"
    [ -z "$pids" ] || kill -9 $pids 2>/dev/null || true
}

# ---- procd lifecycle ----

start_service() {
    # Generate/refresh nftables include & reload firewall
    regen_rules_and_reload_fw

    # Read watcher env from UCI (@settings[0] consistently)
    local enabled threshold window penalty ports watch_dropbear ignore_private escalate_enable
    enabled="$(get_uciv authshield.@settings[0].enabled)";           [ -n "$enabled" ] || enabled=1
    threshold="$(get_uciv authshield.@settings[0].threshold)";       [ -n "$threshold" ] || threshold=5
    window="$(get_uciv authshield.@settings[0].window)";             [ -n "$window" ] || window=10
    penalty="$(get_uciv authshield.@settings[0].penalty)";           [ -n "$penalty" ] || penalty=60
    ports="$(get_uciv authshield.@settings[0].ports)";               [ -n "$ports" ] || ports="80 443"
    watch_dropbear="$(get_uciv authshield.@settings[0].watch_dropbear)"; [ -n "$watch_dropbear" ] || watch_dropbear=0
    ignore_private="$(get_uciv authshield.@settings[0].ignore_private_ip)"; [ -n "$ignore_private" ] || ignore_private=1
    escalate_enable="$(get_uciv authshield.@settings[0].escalate_enable)"; [ -n "$escalate_enable" ] || escalate_enable=1

    # --- Add port 22 when Dropbear monitoring is enabled ---
    if [ "$watch_dropbear" = "1" ]; then
        case " $ports " in
            *" 22 "*) : ;;  # already has it
            *) ports="$ports 22" ;;
        esac
    fi

    [ "$enabled" -eq 1 ] || return 0

    procd_open_instance
    procd_set_param command "$WATCH_BIN"
    procd_set_param respawn 5 10 5           # (timeout, retry, max)
    procd_set_param stdout 1
    procd_set_param stderr 1
    procd_set_param env THRESHOLD="$threshold"
    procd_set_param env WINDOW="$window"
    procd_set_param env PENALTY="$penalty"
    procd_set_param env PORTS="$ports"
    procd_set_param env WATCH_DROPBEAR="$watch_dropbear"
    procd_set_param env IGNORE_PRIVATE="$ignore_private"
    procd_set_param env ESCALATE_ENABLE="$escalate_enable"
    procd_close_instance
}

stop_service() {
    # procd will stop our instance; we just clean up stragglers
    kill_leftovers
}

reload_service() {
    # Re-read UCI, rebuild procd instance, and relaunch with fresh env
    stop
    start
}

service_triggers() {
    # Reload our service when authshield UCI changes; also when firewall changes.
    procd_add_reload_trigger "authshield" "firewall"
}

# Convenience handler for rc.common `restart`
restart() {
    stop
    start
}
